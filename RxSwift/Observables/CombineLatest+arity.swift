// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
//
//  CombineLatest+arity.swift
//  RxSwift
//
//  Created by Krunoslav Zaher on 4/22/15.
//  Copyright Â© 2015 Krunoslav Zaher. All rights reserved.
//



// 2

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType>
        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) -> Element)
        -> ObservableSource<Element, Completed, Error> where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed {
        return ObservableSource(run: .run { observer, cancel in
            let _lock = RecursiveLock()

            var _latestElement1: O1.Element! = nil
            var _latestElement2: O2.Element! = nil

            let _arity: Int = 2
            var _numberOfValues = 0
            var _numberOfDone = 0
            var _hasValue: [Bool] = [Bool](repeating: false, count: 2)
            var _isDone: [Bool] = [Bool](repeating: false, count: 2)

            func next(_ index: Int) {
                if !_hasValue[index] {
                    _hasValue[index] = true
                    _numberOfValues += 1
                }

                if _numberOfValues == _arity {
                    let result = resultSelector(_latestElement1, _latestElement2)
                    observer(.next(result))
                }
            }

            func fail(_ error: Error) {
                observer(.error(error))
                cancel.dispose()
            }

            func done(_ value: Completed, _ index: Int) {
                if _isDone[index] {
                    return
                }

                _isDone[index] = true
                _numberOfDone += 1

                if _numberOfDone == _arity {
                    observer(.completed(value))
                    cancel.dispose()
                }
            }

            let subscription1 = SingleAssignmentDisposable()
            let subscription2 = SingleAssignmentDisposable()
            
            subscription1.setDisposable(source1.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement1 = value
                    next(0)
                case .error(let error):
                    subscription1.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription1.dispose()
                    done(completed, 0)
                }
            }))
            
            subscription2.setDisposable(source2.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement2 = value
                    next(1)
                case .error(let error):
                    subscription2.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription2.dispose()
                    done(completed, 1)
                }
            }))
            
            return Disposables.create([
                    subscription1,
                    subscription2
            ])
        })
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType>
        (_ source1: O1, _ source2: O2)
        -> ObservableSource<(O1.Element, O2.Element), Completed, Error>  where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed {
        return ObservableSource<(O1.Element, O2.Element), Completed, Error>.combineLatest(
            source1, source2,
            resultSelector: { ($0, $1) }
        )
    }
}



// 3

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) -> Element)
        -> ObservableSource<Element, Completed, Error> where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed {
        return ObservableSource(run: .run { observer, cancel in
            let _lock = RecursiveLock()

            var _latestElement1: O1.Element! = nil
            var _latestElement2: O2.Element! = nil
            var _latestElement3: O3.Element! = nil

            let _arity: Int = 3
            var _numberOfValues = 0
            var _numberOfDone = 0
            var _hasValue: [Bool] = [Bool](repeating: false, count: 3)
            var _isDone: [Bool] = [Bool](repeating: false, count: 3)

            func next(_ index: Int) {
                if !_hasValue[index] {
                    _hasValue[index] = true
                    _numberOfValues += 1
                }

                if _numberOfValues == _arity {
                    let result = resultSelector(_latestElement1, _latestElement2, _latestElement3)
                    observer(.next(result))
                }
            }

            func fail(_ error: Error) {
                observer(.error(error))
                cancel.dispose()
            }

            func done(_ value: Completed, _ index: Int) {
                if _isDone[index] {
                    return
                }

                _isDone[index] = true
                _numberOfDone += 1

                if _numberOfDone == _arity {
                    observer(.completed(value))
                    cancel.dispose()
                }
            }

            let subscription1 = SingleAssignmentDisposable()
            let subscription2 = SingleAssignmentDisposable()
            let subscription3 = SingleAssignmentDisposable()
            
            subscription1.setDisposable(source1.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement1 = value
                    next(0)
                case .error(let error):
                    subscription1.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription1.dispose()
                    done(completed, 0)
                }
            }))
            
            subscription2.setDisposable(source2.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement2 = value
                    next(1)
                case .error(let error):
                    subscription2.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription2.dispose()
                    done(completed, 1)
                }
            }))
            
            subscription3.setDisposable(source3.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement3 = value
                    next(2)
                case .error(let error):
                    subscription3.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription3.dispose()
                    done(completed, 2)
                }
            }))
            
            return Disposables.create([
                    subscription1,
                    subscription2,
                    subscription3
            ])
        })
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3)
        -> ObservableSource<(O1.Element, O2.Element, O3.Element), Completed, Error>  where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed {
        return ObservableSource<(O1.Element, O2.Element, O3.Element), Completed, Error>.combineLatest(
            source1, source2, source3,
            resultSelector: { ($0, $1, $2) }
        )
    }
}



// 4

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) -> Element)
        -> ObservableSource<Element, Completed, Error> where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed {
        return ObservableSource(run: .run { observer, cancel in
            let _lock = RecursiveLock()

            var _latestElement1: O1.Element! = nil
            var _latestElement2: O2.Element! = nil
            var _latestElement3: O3.Element! = nil
            var _latestElement4: O4.Element! = nil

            let _arity: Int = 4
            var _numberOfValues = 0
            var _numberOfDone = 0
            var _hasValue: [Bool] = [Bool](repeating: false, count: 4)
            var _isDone: [Bool] = [Bool](repeating: false, count: 4)

            func next(_ index: Int) {
                if !_hasValue[index] {
                    _hasValue[index] = true
                    _numberOfValues += 1
                }

                if _numberOfValues == _arity {
                    let result = resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4)
                    observer(.next(result))
                }
            }

            func fail(_ error: Error) {
                observer(.error(error))
                cancel.dispose()
            }

            func done(_ value: Completed, _ index: Int) {
                if _isDone[index] {
                    return
                }

                _isDone[index] = true
                _numberOfDone += 1

                if _numberOfDone == _arity {
                    observer(.completed(value))
                    cancel.dispose()
                }
            }

            let subscription1 = SingleAssignmentDisposable()
            let subscription2 = SingleAssignmentDisposable()
            let subscription3 = SingleAssignmentDisposable()
            let subscription4 = SingleAssignmentDisposable()
            
            subscription1.setDisposable(source1.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement1 = value
                    next(0)
                case .error(let error):
                    subscription1.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription1.dispose()
                    done(completed, 0)
                }
            }))
            
            subscription2.setDisposable(source2.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement2 = value
                    next(1)
                case .error(let error):
                    subscription2.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription2.dispose()
                    done(completed, 1)
                }
            }))
            
            subscription3.setDisposable(source3.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement3 = value
                    next(2)
                case .error(let error):
                    subscription3.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription3.dispose()
                    done(completed, 2)
                }
            }))
            
            subscription4.setDisposable(source4.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement4 = value
                    next(3)
                case .error(let error):
                    subscription4.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription4.dispose()
                    done(completed, 3)
                }
            }))
            
            return Disposables.create([
                    subscription1,
                    subscription2,
                    subscription3,
                    subscription4
            ])
        })
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
        -> ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element), Completed, Error>  where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed {
        return ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element), Completed, Error>.combineLatest(
            source1, source2, source3, source4,
            resultSelector: { ($0, $1, $2, $3) }
        )
    }
}



// 5

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) -> Element)
        -> ObservableSource<Element, Completed, Error> where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed {
        return ObservableSource(run: .run { observer, cancel in
            let _lock = RecursiveLock()

            var _latestElement1: O1.Element! = nil
            var _latestElement2: O2.Element! = nil
            var _latestElement3: O3.Element! = nil
            var _latestElement4: O4.Element! = nil
            var _latestElement5: O5.Element! = nil

            let _arity: Int = 5
            var _numberOfValues = 0
            var _numberOfDone = 0
            var _hasValue: [Bool] = [Bool](repeating: false, count: 5)
            var _isDone: [Bool] = [Bool](repeating: false, count: 5)

            func next(_ index: Int) {
                if !_hasValue[index] {
                    _hasValue[index] = true
                    _numberOfValues += 1
                }

                if _numberOfValues == _arity {
                    let result = resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5)
                    observer(.next(result))
                }
            }

            func fail(_ error: Error) {
                observer(.error(error))
                cancel.dispose()
            }

            func done(_ value: Completed, _ index: Int) {
                if _isDone[index] {
                    return
                }

                _isDone[index] = true
                _numberOfDone += 1

                if _numberOfDone == _arity {
                    observer(.completed(value))
                    cancel.dispose()
                }
            }

            let subscription1 = SingleAssignmentDisposable()
            let subscription2 = SingleAssignmentDisposable()
            let subscription3 = SingleAssignmentDisposable()
            let subscription4 = SingleAssignmentDisposable()
            let subscription5 = SingleAssignmentDisposable()
            
            subscription1.setDisposable(source1.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement1 = value
                    next(0)
                case .error(let error):
                    subscription1.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription1.dispose()
                    done(completed, 0)
                }
            }))
            
            subscription2.setDisposable(source2.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement2 = value
                    next(1)
                case .error(let error):
                    subscription2.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription2.dispose()
                    done(completed, 1)
                }
            }))
            
            subscription3.setDisposable(source3.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement3 = value
                    next(2)
                case .error(let error):
                    subscription3.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription3.dispose()
                    done(completed, 2)
                }
            }))
            
            subscription4.setDisposable(source4.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement4 = value
                    next(3)
                case .error(let error):
                    subscription4.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription4.dispose()
                    done(completed, 3)
                }
            }))
            
            subscription5.setDisposable(source5.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement5 = value
                    next(4)
                case .error(let error):
                    subscription5.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription5.dispose()
                    done(completed, 4)
                }
            }))
            
            return Disposables.create([
                    subscription1,
                    subscription2,
                    subscription3,
                    subscription4,
                    subscription5
            ])
        })
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
        -> ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element), Completed, Error>  where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed {
        return ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element), Completed, Error>.combineLatest(
            source1, source2, source3, source4, source5,
            resultSelector: { ($0, $1, $2, $3, $4) }
        )
    }
}



// 6

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) -> Element)
        -> ObservableSource<Element, Completed, Error> where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed, O6.Error == Error, O6.Completed == Completed {
        return ObservableSource(run: .run { observer, cancel in
            let _lock = RecursiveLock()

            var _latestElement1: O1.Element! = nil
            var _latestElement2: O2.Element! = nil
            var _latestElement3: O3.Element! = nil
            var _latestElement4: O4.Element! = nil
            var _latestElement5: O5.Element! = nil
            var _latestElement6: O6.Element! = nil

            let _arity: Int = 6
            var _numberOfValues = 0
            var _numberOfDone = 0
            var _hasValue: [Bool] = [Bool](repeating: false, count: 6)
            var _isDone: [Bool] = [Bool](repeating: false, count: 6)

            func next(_ index: Int) {
                if !_hasValue[index] {
                    _hasValue[index] = true
                    _numberOfValues += 1
                }

                if _numberOfValues == _arity {
                    let result = resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5, _latestElement6)
                    observer(.next(result))
                }
            }

            func fail(_ error: Error) {
                observer(.error(error))
                cancel.dispose()
            }

            func done(_ value: Completed, _ index: Int) {
                if _isDone[index] {
                    return
                }

                _isDone[index] = true
                _numberOfDone += 1

                if _numberOfDone == _arity {
                    observer(.completed(value))
                    cancel.dispose()
                }
            }

            let subscription1 = SingleAssignmentDisposable()
            let subscription2 = SingleAssignmentDisposable()
            let subscription3 = SingleAssignmentDisposable()
            let subscription4 = SingleAssignmentDisposable()
            let subscription5 = SingleAssignmentDisposable()
            let subscription6 = SingleAssignmentDisposable()
            
            subscription1.setDisposable(source1.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement1 = value
                    next(0)
                case .error(let error):
                    subscription1.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription1.dispose()
                    done(completed, 0)
                }
            }))
            
            subscription2.setDisposable(source2.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement2 = value
                    next(1)
                case .error(let error):
                    subscription2.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription2.dispose()
                    done(completed, 1)
                }
            }))
            
            subscription3.setDisposable(source3.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement3 = value
                    next(2)
                case .error(let error):
                    subscription3.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription3.dispose()
                    done(completed, 2)
                }
            }))
            
            subscription4.setDisposable(source4.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement4 = value
                    next(3)
                case .error(let error):
                    subscription4.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription4.dispose()
                    done(completed, 3)
                }
            }))
            
            subscription5.setDisposable(source5.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement5 = value
                    next(4)
                case .error(let error):
                    subscription5.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription5.dispose()
                    done(completed, 4)
                }
            }))
            
            subscription6.setDisposable(source6.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement6 = value
                    next(5)
                case .error(let error):
                    subscription6.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription6.dispose()
                    done(completed, 5)
                }
            }))
            
            return Disposables.create([
                    subscription1,
                    subscription2,
                    subscription3,
                    subscription4,
                    subscription5,
                    subscription6
            ])
        })
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
        -> ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element), Completed, Error>  where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed, O6.Error == Error, O6.Completed == Completed {
        return ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element), Completed, Error>.combineLatest(
            source1, source2, source3, source4, source5, source6,
            resultSelector: { ($0, $1, $2, $3, $4, $5) }
        )
    }
}



// 7

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) -> Element)
        -> ObservableSource<Element, Completed, Error> where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed, O6.Error == Error, O6.Completed == Completed, O7.Error == Error, O7.Completed == Completed {
        return ObservableSource(run: .run { observer, cancel in
            let _lock = RecursiveLock()

            var _latestElement1: O1.Element! = nil
            var _latestElement2: O2.Element! = nil
            var _latestElement3: O3.Element! = nil
            var _latestElement4: O4.Element! = nil
            var _latestElement5: O5.Element! = nil
            var _latestElement6: O6.Element! = nil
            var _latestElement7: O7.Element! = nil

            let _arity: Int = 7
            var _numberOfValues = 0
            var _numberOfDone = 0
            var _hasValue: [Bool] = [Bool](repeating: false, count: 7)
            var _isDone: [Bool] = [Bool](repeating: false, count: 7)

            func next(_ index: Int) {
                if !_hasValue[index] {
                    _hasValue[index] = true
                    _numberOfValues += 1
                }

                if _numberOfValues == _arity {
                    let result = resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5, _latestElement6, _latestElement7)
                    observer(.next(result))
                }
            }

            func fail(_ error: Error) {
                observer(.error(error))
                cancel.dispose()
            }

            func done(_ value: Completed, _ index: Int) {
                if _isDone[index] {
                    return
                }

                _isDone[index] = true
                _numberOfDone += 1

                if _numberOfDone == _arity {
                    observer(.completed(value))
                    cancel.dispose()
                }
            }

            let subscription1 = SingleAssignmentDisposable()
            let subscription2 = SingleAssignmentDisposable()
            let subscription3 = SingleAssignmentDisposable()
            let subscription4 = SingleAssignmentDisposable()
            let subscription5 = SingleAssignmentDisposable()
            let subscription6 = SingleAssignmentDisposable()
            let subscription7 = SingleAssignmentDisposable()
            
            subscription1.setDisposable(source1.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement1 = value
                    next(0)
                case .error(let error):
                    subscription1.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription1.dispose()
                    done(completed, 0)
                }
            }))
            
            subscription2.setDisposable(source2.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement2 = value
                    next(1)
                case .error(let error):
                    subscription2.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription2.dispose()
                    done(completed, 1)
                }
            }))
            
            subscription3.setDisposable(source3.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement3 = value
                    next(2)
                case .error(let error):
                    subscription3.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription3.dispose()
                    done(completed, 2)
                }
            }))
            
            subscription4.setDisposable(source4.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement4 = value
                    next(3)
                case .error(let error):
                    subscription4.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription4.dispose()
                    done(completed, 3)
                }
            }))
            
            subscription5.setDisposable(source5.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement5 = value
                    next(4)
                case .error(let error):
                    subscription5.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription5.dispose()
                    done(completed, 4)
                }
            }))
            
            subscription6.setDisposable(source6.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement6 = value
                    next(5)
                case .error(let error):
                    subscription6.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription6.dispose()
                    done(completed, 5)
                }
            }))
            
            subscription7.setDisposable(source7.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement7 = value
                    next(6)
                case .error(let error):
                    subscription7.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription7.dispose()
                    done(completed, 6)
                }
            }))
            
            return Disposables.create([
                    subscription1,
                    subscription2,
                    subscription3,
                    subscription4,
                    subscription5,
                    subscription6,
                    subscription7
            ])
        })
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
        -> ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element), Completed, Error>  where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed, O6.Error == Error, O6.Completed == Completed, O7.Error == Error, O7.Completed == Completed {
        return ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element), Completed, Error>.combineLatest(
            source1, source2, source3, source4, source5, source6, source7,
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
        )
    }
}



// 8

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) -> Element)
        -> ObservableSource<Element, Completed, Error> where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed, O6.Error == Error, O6.Completed == Completed, O7.Error == Error, O7.Completed == Completed, O8.Error == Error, O8.Completed == Completed {
        return ObservableSource(run: .run { observer, cancel in
            let _lock = RecursiveLock()

            var _latestElement1: O1.Element! = nil
            var _latestElement2: O2.Element! = nil
            var _latestElement3: O3.Element! = nil
            var _latestElement4: O4.Element! = nil
            var _latestElement5: O5.Element! = nil
            var _latestElement6: O6.Element! = nil
            var _latestElement7: O7.Element! = nil
            var _latestElement8: O8.Element! = nil

            let _arity: Int = 8
            var _numberOfValues = 0
            var _numberOfDone = 0
            var _hasValue: [Bool] = [Bool](repeating: false, count: 8)
            var _isDone: [Bool] = [Bool](repeating: false, count: 8)

            func next(_ index: Int) {
                if !_hasValue[index] {
                    _hasValue[index] = true
                    _numberOfValues += 1
                }

                if _numberOfValues == _arity {
                    let result = resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5, _latestElement6, _latestElement7, _latestElement8)
                    observer(.next(result))
                }
            }

            func fail(_ error: Error) {
                observer(.error(error))
                cancel.dispose()
            }

            func done(_ value: Completed, _ index: Int) {
                if _isDone[index] {
                    return
                }

                _isDone[index] = true
                _numberOfDone += 1

                if _numberOfDone == _arity {
                    observer(.completed(value))
                    cancel.dispose()
                }
            }

            let subscription1 = SingleAssignmentDisposable()
            let subscription2 = SingleAssignmentDisposable()
            let subscription3 = SingleAssignmentDisposable()
            let subscription4 = SingleAssignmentDisposable()
            let subscription5 = SingleAssignmentDisposable()
            let subscription6 = SingleAssignmentDisposable()
            let subscription7 = SingleAssignmentDisposable()
            let subscription8 = SingleAssignmentDisposable()
            
            subscription1.setDisposable(source1.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement1 = value
                    next(0)
                case .error(let error):
                    subscription1.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription1.dispose()
                    done(completed, 0)
                }
            }))
            
            subscription2.setDisposable(source2.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement2 = value
                    next(1)
                case .error(let error):
                    subscription2.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription2.dispose()
                    done(completed, 1)
                }
            }))
            
            subscription3.setDisposable(source3.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement3 = value
                    next(2)
                case .error(let error):
                    subscription3.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription3.dispose()
                    done(completed, 2)
                }
            }))
            
            subscription4.setDisposable(source4.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement4 = value
                    next(3)
                case .error(let error):
                    subscription4.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription4.dispose()
                    done(completed, 3)
                }
            }))
            
            subscription5.setDisposable(source5.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement5 = value
                    next(4)
                case .error(let error):
                    subscription5.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription5.dispose()
                    done(completed, 4)
                }
            }))
            
            subscription6.setDisposable(source6.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement6 = value
                    next(5)
                case .error(let error):
                    subscription6.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription6.dispose()
                    done(completed, 5)
                }
            }))
            
            subscription7.setDisposable(source7.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement7 = value
                    next(6)
                case .error(let error):
                    subscription7.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription7.dispose()
                    done(completed, 6)
                }
            }))
            
            subscription8.setDisposable(source8.source.subscribe({ event in
                switch event {
                case .next(let value):
                    _latestElement8 = value
                    next(7)
                case .error(let error):
                    subscription8.dispose()
                    fail(error)
                case .completed(let completed):
                    subscription8.dispose()
                    done(completed, 7)
                }
            }))
            
            return Disposables.create([
                    subscription1,
                    subscription2,
                    subscription3,
                    subscription4,
                    subscription5,
                    subscription6,
                    subscription7,
                    subscription8
            ])
        })
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
        -> ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element), Completed, Error>  where O1.Error == Error, O1.Completed == Completed, O2.Error == Error, O2.Completed == Completed, O3.Error == Error, O3.Completed == Completed, O4.Error == Error, O4.Completed == Completed, O5.Error == Error, O5.Completed == Completed, O6.Error == Error, O6.Completed == Completed, O7.Error == Error, O7.Completed == Completed, O8.Error == Error, O8.Completed == Completed {
        return ObservableSource<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element), Completed, Error>.combineLatest(
            source1, source2, source3, source4, source5, source6, source7, source8,
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
        )
    }
}


